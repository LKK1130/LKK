import streamlit as st
import random
import datetime
import json
import time
import os
from collections import Counter
from datetime import datetime as dt, timedelta
import streamlit.components.v1 as components
import matplotlib.pyplot as plt 

# --------------------
# å‡è³‡æ–™ï¼ˆç”¨æ–¼ç™»å…¥é©—è­‰ï¼‰
# --------------------
FAKE_USERS = {
    "user1": "password1",
    "user2": "password2",
    "admin": "admin123"
}

FAKE_CHECKINS = []  # æ¨¡æ“¬æ‰“å¡ç´€éŒ„

# --------------------
# å–®å­—æ°¸ä¹…å„²å­˜åŠŸèƒ½
# --------------------
WORDS_FILE = "words.json"
TODAY_WORDS_FILE = f"today_words_{datetime.date.today().isoformat()}.json"

def load_words():
    if os.path.exists(WORDS_FILE):
        with open(WORDS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    else:
        return []

def save_words(words):
    with open(WORDS_FILE, "w", encoding="utf-8") as f:
        json.dump(words, f, ensure_ascii=False, indent=2)

def load_today_words():
    if os.path.exists(TODAY_WORDS_FILE):
        with open(TODAY_WORDS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    else:
        return []

def save_today_words(words):
    with open(TODAY_WORDS_FILE, "w", encoding="utf-8") as f:
        json.dump(words, f, ensure_ascii=False, indent=2)

# åœ¨ä¸»ç¨‹å¼ä¸€é–‹å§‹è¼‰å…¥
if "words_data" not in st.session_state:
    st.session_state["words_data"] = load_words()

if "words" not in st.session_state:
    st.session_state["words"] = load_today_words()

# --------------------
# é¸æ“‡é¡Œæ¸¬é©—åŠŸèƒ½
# --------------------
def generate_choice_questions():
    words = st.session_state["words_data"]
    questions = []
    if len(words) < 2:
        return questions  # è‡³å°‘è¦å…©å€‹å–®å­—æ‰æœ‰å¹²æ“¾é¸é …
    for w in words:
        options = [w["meaning"]]
        distractors = [x["meaning"] for x in words if x["word"] != w["word"] and x["meaning"]]
        options += random.sample(distractors, min(3, len(distractors)))
        random.shuffle(options)
        answer_index = options.index(w["meaning"])
        questions.append({
            "word": w["word"],
            "options": options,
            "answer_index": answer_index
        })
    return questions

def quiz_page():
    st.title("ğŸ“˜ å­¸ç¿’å–®å­—é¸æ“‡é¡Œæ¸¬é©—")
    num_options = [5, 10, 20]
    words_total = len(st.session_state["words_data"])

    # åªåœ¨ quiz_started ç‚º False æ™‚é¡¯ç¤ºé¸æ“‡é¡Œæ•¸èˆ‡é–‹å§‹æ¸¬é©—
    if "quiz_started" not in st.session_state or not st.session_state.quiz_started:
        num_q = st.radio("è«‹é¸æ“‡æ¸¬é©—é¡Œæ•¸ï¼š", num_options, horizontal=True, index=0, key="quiz_num_select")
        if words_total == 0:
            st.info("è«‹å…ˆåœ¨å­¸ç¿’é æ–°å¢å–®å­—ã€‚")
            return

        actual_num = min(num_q, words_total)
        if st.button("é–‹å§‹æ¸¬é©—"):
            all_questions = generate_choice_questions()
            if len(all_questions) > actual_num:
                questions = random.sample(all_questions, actual_num)
            else:
                questions = all_questions
            st.session_state.quiz_questions = questions
            st.session_state.current_q = 0
            st.session_state.score = 0
            st.session_state.log = []
            st.session_state.quiz_started = True
        else:
            return  # é‚„æ²’æŒ‰é–‹å§‹æ¸¬é©—å°±ä¸é¡¯ç¤ºé¡Œç›®

    questions = st.session_state.get("quiz_questions", [])

    if not questions:
        st.info("è«‹å…ˆåœ¨å­¸ç¿’é æ–°å¢è‡³å°‘å…©å€‹æœ‰æ„æ€çš„å–®å­—ï¼Œæ‰èƒ½é€²è¡Œé¸æ“‡é¡Œæ¸¬é©—ã€‚")
        return

    if st.session_state.current_q < len(questions):
        q = questions[st.session_state.current_q]
        st.subheader(f"é¡Œç›® {st.session_state.current_q + 1}: {q['word']}")
        choice = st.radio("è«‹é¸æ“‡æ­£ç¢ºæ„æ€ï¼š", q["options"], index=None, key=f"quiz_choice_{st.session_state.current_q}")

        if st.button("æäº¤ç­”æ¡ˆ", key=f"submit_{st.session_state.current_q}") and choice is not None:
            correct = q["options"].index(choice) == q["answer_index"]
            if correct:
                st.success("âœ… ç­”å°äº†ï¼")
                st.session_state.score += 1
            else:
                st.error(f"âŒ ç­”éŒ¯äº†ï¼Œæ­£ç¢ºç­”æ¡ˆæ˜¯ï¼š{q['options'][q['answer_index']]}")
            # ä¸è«–å°éŒ¯éƒ½å¯«å…¥ log.json
            log_item = {
                "word": q["word"],
                "your_answer": choice,
                "correct_answer": q["options"][q["answer_index"]],
                "is_correct": correct
            }
            if os.path.exists("log.json"):
                with open("log.json", "r", encoding="utf-8") as f:
                    old_log = json.load(f)
            else:
                old_log = []
            old_log.append(log_item)
            with open("log.json", "w", encoding="utf-8") as f:
                json.dump(old_log, f, ensure_ascii=False, indent=2)
            st.session_state.log.append(log_item)
            st.session_state.current_q += 1
            st.session_state.pop(f"quiz_choice_{st.session_state.current_q-1}", None)
    else:
        st.balloons()
        st.markdown(f"### ğŸ‰ æ¸¬é©—çµæŸï¼ç¸½åˆ†ï¼š{st.session_state.score}/{len(questions)}")
        st.write("### ğŸ“Š å­¸ç¿’ç´€éŒ„")
        st.json(st.session_state.log)

        # æ¸¬é©—çµæŸï¼Œè¨ˆç®—æœ¬æ¬¡åˆ†æ
        quiz_time = dt.now().strftime("%Y-%m-%d %H:%M:%S")
        total = len(questions)
        correct = st.session_state.score
        accuracy = round((correct / total) * 100, 2) if total > 0 else 0
        wrong_words = [item["word"] for item in st.session_state.log if not item["is_correct"]]
        wrong_words_str = ", ".join(wrong_words) if wrong_words else "ç„¡"

        # å„²å­˜åˆ° quiz_result.jsonï¼ˆé¿å…é‡è¤‡ï¼Œä¾ é¡Œæ•¸+æ­£ç¢ºç‡+éŒ¯èª¤å–®å­— åˆ¤æ–·ï¼‰
        result_row = {
            "æ¸¬é©—æ™‚é–“": quiz_time,
            "é¡Œæ•¸": total,
            "æ­£ç¢ºç‡": f"{accuracy}%",
            "éŒ¯èª¤å–®å­—": wrong_words_str
        }
        if os.path.exists("quiz_result.json"):
            with open("quiz_result.json", "r", encoding="utf-8") as f:
                quiz_results = json.load(f)
        else:
            quiz_results = []
        # æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰ç›¸åŒã€Œé¡Œæ•¸ã€æ­£ç¢ºç‡ã€éŒ¯èª¤å–®å­—ã€çš„ç´€éŒ„
        is_duplicate = any(
            (r.get("é¡Œæ•¸") == total and
             r.get("æ­£ç¢ºç‡") == f"{accuracy}%" and
             r.get("éŒ¯èª¤å–®å­—") == wrong_words_str)
            for r in quiz_results
        )
        if not is_duplicate:
            quiz_results.append(result_row)
            with open("quiz_result.json", "w", encoding="utf-8") as f:
                json.dump(quiz_results, f, ensure_ascii=False, indent=2)

        if st.button("é‡æ–°é–‹å§‹"):
            # é‡æ–°é¸é¡Œæ•¸
            st.session_state.quiz_questions = []
            st.session_state.current_q = 0
            st.session_state.score = 0
            st.session_state.log = []
            st.session_state.quiz_started = False  # é—œéµï¼šè®“é¸é¡Œæ•¸ç•«é¢å›ä¾†
            st.experimental_rerun() if hasattr(st, "experimental_rerun") else st.rerun()

# --------------------
# å„é é¢åŠŸèƒ½
# --------------------
def home_page():
    st.title("æ­¡è¿ä¾†åˆ°èƒŒå–®å­—ç¿’æ…£è¿½è¹¤ç³»çµ±")
    st.write("é€™æ˜¯ä¸€å€‹å¹«åŠ©æ‚¨è¿½è¹¤æ¯æ—¥å­¸ç¿’é€²åº¦èˆ‡æ¸¬é©—è¨˜æ†¶æ•ˆæœçš„æ‡‰ç”¨ç¨‹å¼ã€‚")
    st.write("è«‹ä½¿ç”¨å·¦å´é¸å–®é€²è¡Œæ“ä½œã€‚")
    st.image("https://via.placeholder.com/800x300", caption="å­¸ç¿’ï¼Œæ¸¬é©—ï¼Œé€²æ­¥ï¼")

def login_page():
    st.title("ç™»å…¥")
    username_input = st.text_input("è«‹è¼¸å…¥å¸³è™Ÿ", key="login_username")
    password_input = st.text_input("è«‹è¼¸å…¥å¯†ç¢¼", type="password", key="login_password")
    if st.button("ç™»å…¥"):
        if username_input in FAKE_USERS and FAKE_USERS[username_input] == password_input:
            st.session_state["logged_in"] = True
            st.session_state["current_user"] = username_input
            st.success(f"æ­¡è¿ï¼Œ{username_input}ï¼ç™»å…¥æˆåŠŸï¼")
        else:
            st.error("å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤ï¼")

def study_page():
    st.title("å­¸ç¿’é ")
    st.write(f"ä»Šå¤©æ˜¯ï¼š{datetime.date.today().isoformat()}")

    col1, col2 = st.columns(2)
    with col1:
        new_word = st.text_input("è¼¸å…¥è‹±æ–‡å–®å­—").strip().lower()
    with col2:
        new_meaning = st.text_input("è¼¸å…¥ä¸­æ–‡æ„æ€").strip()

    if st.button("æ–°å¢å–®å­—"):
        if new_word and new_meaning:
            exist = next((w for w in st.session_state["words_data"] if w["word"].lower() == new_word), None)
            if exist:
                exist["meaning"] = new_meaning  # æ›´æ–°æ„æ€
            else:
                st.session_state["words_data"].append({
                    "word": new_word,
                    "meaning": new_meaning,
                    "level": 1,
                    "last_review": datetime.date.today().isoformat()
                })
            save_words(st.session_state["words_data"])
            if "words" not in st.session_state:
                st.session_state["words"] = []
            if new_word not in [w.lower() for w in st.session_state["words"]]:
                st.session_state["words"].append(new_word)
                save_today_words(st.session_state["words"])
            st.success(f"å·²æ–°å¢ï¼š{new_word} - {new_meaning}")
        else:
            st.error("è«‹è¼¸å…¥å®Œæ•´çš„è‹±æ–‡å–®å­—èˆ‡ä¸­æ–‡æ„æ€ï¼")

    if st.button("å®Œæˆä»Šæ—¥å­¸ç¿’"):
        user = st.session_state.get("current_user", "")
        response = {
            "user": user,
            "date": datetime.date.today().isoformat(),
            "words_learned": st.session_state.get("words", [])
        }
        st.success("ä»Šæ—¥å­¸ç¿’å·²å®Œæˆï¼")
        st.json(response)

        # æ–°å¢ï¼šå¯«å…¥ä¸€ç­†å­¸ç¿’æ‰“å¡åˆ° checkin.json
        checkin_record = {
            "user": user,
            "datetime": dt.now().strftime("%Y-%m-%d %H:%M:%S"),
            "type": "study",  # æ¨™è¨˜é€™æ˜¯å­¸ç¿’æ‰“å¡
            "words_learned": st.session_state.get("words", [])
        }
        if os.path.exists("checkin.json"):
            with open("checkin.json", "r", encoding="utf-8") as f:
                checkins = json.load(f)
        else:
            checkins = []
        checkins.append(checkin_record)
        with open("checkin.json", "w", encoding="utf-8") as f:
            json.dump(checkins, f, ensure_ascii=False, indent=2)

    st.subheader("å·²å­¸å–®å­—")
    if "words" in st.session_state and st.session_state["words"]:
        for word in st.session_state["words"]:
            meaning = next((w["meaning"] for w in st.session_state["words_data"] if w["word"].lower() == word.lower()), "")
            st.write(f"- {word}ï¼ˆ{meaning}ï¼‰")
    else:
        st.write("å°šæœªè¨˜éŒ„ä»»ä½•å–®å­—ã€‚")

def word_cards_page():
    st.title("å–®å­—å¡ç‰‡")
    if "words" in st.session_state and st.session_state["words"]:
        for word in st.session_state["words"]:
            word_key = word.strip().lower()
            meaning = next((w["meaning"] for w in st.session_state["words_data"] if w["word"].strip().lower() == word_key and w["meaning"]), None)
            if meaning:
                with st.expander(f"å–®å­—: {word}"):
                    st.write(f"æ„æ€: {meaning}")
            else:
                st.write(f"- {word}ï¼ˆå°šæœªè¼¸å…¥æ„æ€ï¼Œè«‹å›å­¸ç¿’é è£œä¸Šï¼‰")
    else:
        st.info("å°šæœªè¨˜éŒ„ä»»ä½•å–®å­—ï¼Œè«‹å…ˆåˆ°å­¸ç¿’é æ–°å¢å–®å­—ã€‚")

def stats_page():
    st.title("å–®å­—æ¸¬é©—çµæœåˆ†æå ±å‘Š")
    # è®€å– log.json
    if not os.path.exists("log.json"):
        st.warning("å°šæœªç™¼ç¾æ¸¬é©—ç´€éŒ„æª” log.jsonï¼Œè«‹å…ˆå®Œæˆæ¸¬é©—ä¸¦å„²å­˜ç´€éŒ„ã€‚")
        return

    with open("log.json", "r", encoding="utf-8") as f:
        log_data = json.load(f)

    # åˆ†æéŒ¯èª¤ç‡èˆ‡éŒ¯èª¤å–®å­—
    total = len(log_data)
    correct = sum(1 for item in log_data if item["is_correct"])
    wrong = total - correct
    accuracy = round((correct / total) * 100, 2) if total > 0 else 0
    error_rate = round(100 - accuracy, 2) if total > 0 else 0

    # éŒ¯èª¤å–®å­—çµ±è¨ˆ
    wrong_words = [item["word"] for item in log_data if not item["is_correct"]]
    wrong_counts = Counter(wrong_words).most_common()

    # é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
    st.subheader("æ¸¬é©—çµ±è¨ˆ")
    st.write(f"ç¸½é¡Œæ•¸ï¼š{total}")
    st.write(f"æ­£ç¢ºé¡Œæ•¸ï¼š{correct}")
    st.write(f"éŒ¯èª¤é¡Œæ•¸ï¼š{wrong}")
    st.write(f"æ­£ç¢ºç‡ï¼š{accuracy}%")

    # éºå¿˜å–®å­—å–®å­—æç¤º
    if wrong_counts:
        st.subheader("éºå¿˜å–®å­—æç¤º")
        st.info("ä»¥ä¸‹å–®å­—æ›¾ç¶“ç­”éŒ¯å¤šæ¬¡ï¼Œå»ºè­°é‡è¤‡è¤‡ç¿’ï¼š")
        for word, count in wrong_counts:
            st.write(f"- **{word}**ï¼šéŒ¯èª¤æ¬¡æ•¸ {count} æ¬¡")

    # æ­·å²æ¸¬é©—åˆ†æç´€éŒ„è¡¨æ ¼
    if os.path.exists("quiz_result.json"):
        with open("quiz_result.json", "r", encoding="utf-8") as f:
            quiz_results = json.load(f)
        # æ–°å¢ï¼šåŠ ä¸Šç·¨è™Ÿï¼Œå¾1é–‹å§‹
        for idx, row in enumerate(quiz_results, start=1):
            row["ç·¨è™Ÿ"] = idx
        # è®“ã€Œç·¨è™Ÿã€é¡¯ç¤ºåœ¨æœ€å‰é¢
        if quiz_results:
            cols = ["ç·¨è™Ÿ"] + [k for k in quiz_results[0] if k != "ç·¨è™Ÿ"]
            st.subheader("ğŸ“Š æ­·å²æ¸¬é©—åˆ†æç´€éŒ„")
            st.table([{k: row[k] for k in cols} for row in quiz_results])
        else:
            st.subheader("ğŸ“Š æ­·å²æ¸¬é©—åˆ†æç´€éŒ„")
            st.write("å°šç„¡ç´€éŒ„")

    # æ­·å²æ¸¬é©—åˆ†æç´€éŒ„ç®¡ç†ï¼ˆåˆªé™¤æŒ‰éˆ•ï¼‰
    st.subheader("ğŸ“Š æ­·å²æ¸¬é©—åˆ†æç´€éŒ„ç®¡ç†")
    if st.button("åˆªé™¤æ‰€æœ‰æ­·å²æ¸¬é©—åˆ†æç´€éŒ„ï¼ˆquiz_result.jsonï¼‰"):
        if os.path.exists("quiz_result.json"):
            with open("quiz_result.json", "w", encoding="utf-8") as f:
                json.dump([], f, ensure_ascii=False, indent=2)
        st.success("å·²åˆªé™¤ quiz_result.jsonï¼")

    # è®€å– checkin.json
    if os.path.exists("checkin.json"):
        with open("checkin.json", "r", encoding="utf-8") as f:
            checkins = json.load(f)
        # è¨ˆç®—æ‰€æœ‰æ‰“å¡ï¼ˆå­¸ç¿’èˆ‡æ¸¬é©—ï¼‰
        answer_count = len(checkins)
        # å–å‡ºæ‰€æœ‰æ‰“å¡æ—¥æœŸ
        answer_dates = [c["datetime"][:10] for c in checkins]
        unique_dates = sorted(set(answer_dates))
        # è¨ˆç®—æœ€é•·é€£çºŒæ‰“å¡å¤©æ•¸
        max_streak = 0
        streak = 0
        last_date = None
        for d in unique_dates:
            d_obj = dt.strptime(d, "%Y-%m-%d")
            if last_date is None or (d_obj - last_date).days == 1:
                streak += 1
            else:
                streak = 1
            if streak > max_streak:
                max_streak = streak
            last_date = d_obj
        st.subheader("æ‰“å¡åˆ†æ")
        st.write(f"ç´¯ç©æ‰“å¡å¤©æ•¸ï¼š{len(unique_dates)}")
        st.write(f"æœ€é•·é€£çºŒæ‰“å¡å¤©æ•¸ï¼š{max_streak}")
    else:
        st.subheader("æ‰“å¡åˆ†æ")
        st.info("ç›®å‰æ²’æœ‰æ‰“å¡ç´€éŒ„ã€‚")

    # åŠ å…¥æ¸…ç©ºæ‰“å¡è³‡æ–™æŒ‰éˆ•
    st.subheader("âš ï¸ æ‰“å¡ç®¡ç†")
    if st.button("æ¸…ç©ºæ‰€æœ‰æ‰“å¡è³‡æ–™ï¼ˆcheckin.jsonï¼‰"):
        for fname in ["checkin.json"]:
            if os.path.exists(fname):
                with open(fname, "w", encoding="utf-8") as f:
                    json.dump([], f, ensure_ascii=False, indent=2)
        st.success("å·²æ¸…ç©º checkin.jsonï¼")
        st.experimental_rerun() if hasattr(st, "experimental_rerun") else st.rerun()

# --------------------
# ä¸»ç¨‹å¼
# --------------------
def main():
    # åˆå§‹åŒ– Session State
    if "logged_in" not in st.session_state:
        st.session_state["logged_in"] = False
    if "words" not in st.session_state:
        st.session_state["words"] = load_today_words()

    # å´é‚Šæ¬„é¸å–®
    st.sidebar.title("èƒŒå–®å­—ç¿’æ…£è¿½è¹¤ç³»çµ±")
    if st.sidebar.button("âš ï¸ æ¸…ç©ºæ‰€æœ‰å–®å­—"):
        clear_words()

    page = None
    if st.session_state["logged_in"]:
        page = st.sidebar.radio("é¸æ“‡é é¢", ["é¦–é ", "å­¸ç¿’", "å–®å­—å¡ç‰‡", "é¸æ“‡é¡Œæ¸¬é©—", "åˆ†æå ±å‘Š", "è¤‡ç¿’"])
    else:
        login_page()
        return

    if page == "é¦–é ":
        home_page()
    elif page == "å­¸ç¿’":
        study_page()
    elif page == "å–®å­—å¡ç‰‡":
        word_cards_page()
    elif page == "é¸æ“‡é¡Œæ¸¬é©—":
        quiz_page()
    elif page == "åˆ†æå ±å‘Š":
        stats_page()
    elif page == "è¤‡ç¿’":
        review_page()

def clear_words():
    st.session_state["words"] = []
    st.session_state["words_data"] = []
    save_words([])  # æ¸…ç©º words.json
    st.success("å·²æ¸…ç©ºæ‰€æœ‰å–®å­—è³‡æ–™ï¼")

def get_due_words(words):
    """å–å¾—ä»Šå¤©éœ€è¦è¤‡ç¿’çš„å–®å­—ï¼ˆä¾levelé–“éš”ï¼‰ï¼Œæ²’æœ‰ last_review çš„å–®å­—ä¹Ÿæœƒå‡ºç¾"""
    today = datetime.date.today()
    level_days = {1: 1, 2: 3, 3: 7, 4: 13, 5: 21}
    due_words = []
    for w in words:
        level = w.get("level", 1)
        last = w.get("last_review")
        if last is None:
            # æ²’æœ‰è¤‡ç¿’éçš„å–®å­—ç›´æ¥åŠ å…¥
            due_words.append(w)
            continue
        last_date = datetime.datetime.strptime(last, "%Y-%m-%d").date()
        interval = level_days.get(level, 1)
        if (today - last_date).days >= interval and level < 5:
            due_words.append(w)
    return due_words

def get_permanent_words(words):
    """å–å¾—æ°¸ä¹…è¨˜æ†¶å€å–®å­—ï¼ˆlevel==5ä¸”å·²ç­”å°ä¸€æ¬¡ï¼‰"""
    today = datetime.date.today()
    level_days = {1: 1, 2: 3, 3: 7, 4: 13, 5: 21}
    permanent = []
    for w in words:
        if w.get("level", 1) == 5:
            last = w.get("last_review", today.isoformat())
            last_date = datetime.datetime.strptime(last, "%Y-%m-%d").date()
            if (today - last_date).days >= level_days[5]:
                permanent.append(w)
    return permanent

def review_page():
    st.title("è¤‡ç¿’")
    tab = st.radio(
        "è«‹é¸æ“‡å€å¡Šï¼š",
        ["è¤‡ç¿’å–®å­—å€", "ç›®å‰å–®å­—è¨˜æ†¶ç‹€æ³", "æ°¸ä¹…è¨˜æ†¶å€"],
        horizontal=True
    )
    words = load_words()
    due_words = get_due_words(words)
    permanent = get_permanent_words(words)
    level_words = {i: [] for i in range(1, 6)}
    for w in words:
        level = w.get("level", 1)
        if level <= 5:
            level_words[level].append(w["word"])

    if tab == "è¤‡ç¿’å–®å­—å€":
        st.subheader("è¤‡ç¿’å–®å­—å€")
        if "review_queue" not in st.session_state or not st.session_state["review_queue"]:
            st.session_state["review_queue"] = random.sample(due_words, len(due_words)) if due_words else []
            st.session_state["review_idx"] = 0
            st.session_state["show_answer"] = False
            st.session_state["level_change_msg"] = ""

        if not st.session_state["review_queue"]:
            st.success("ä»Šæ—¥æ²’æœ‰éœ€è¦è¤‡ç¿’çš„å–®å­—ï¼")
        else:
            idx = st.session_state["review_idx"]
            word_item = st.session_state["review_queue"][idx]
            level_now = word_item.get("level", 1)
            st.markdown(f"**å–®å­—ï¼š{word_item['word']}  ï¼ˆLevel {level_now}ï¼‰**")

            if not st.session_state.get("show_answer", False):
                colA, colB = st.columns(2)
                with colA:
                    if st.button("è¨˜å¾—", key="remember"):
                        for w in words:
                            if w["word"] == word_item["word"]:
                                old_level = w.get("level", 1)
                                new_level = min(old_level + 1, 5)
                                w["level"] = new_level
                                w["last_review"] = datetime.date.today().isoformat()
                                st.session_state["level_change_msg"] = f"Level {old_level} â†’ Level {new_level}"
                                break
                        save_words(words)
                        st.session_state["show_answer"] = True
                with colB:
                    if st.button("å¿˜è¨˜", key="forget"):
                        for w in words:
                            if w["word"] == word_item["word"]:
                                old_level = w.get("level", 1)
                                new_level = max(old_level - 1, 1)
                                w["level"] = new_level
                                w["last_review"] = datetime.date.today().isoformat()
                                st.session_state["level_change_msg"] = f"Level {old_level} â†’ Level {new_level}"
                                break
                        save_words(words)
                        st.session_state["show_answer"] = True
            else:
                st.info(f"ä¸­æ–‡æ„æ€ï¼š{word_item['meaning']}")
                if st.session_state.get("level_change_msg"):
                    st.success(f"ç­‰ç´šè®ŠåŒ–ï¼š{st.session_state['level_change_msg']}")
                if st.button("ä¸‹ä¸€é¡Œ", key="next_word"):
                    st.session_state["review_idx"] += 1
                    st.session_state["show_answer"] = False
                    st.session_state["level_change_msg"] = ""
                    if st.session_state["review_idx"] >= len(st.session_state["review_queue"]):
                        st.session_state["review_queue"] = []
                        st.session_state["review_idx"] = 0
                        st.success("è¤‡ç¿’çµæŸï¼")

    elif tab == "ç›®å‰å–®å­—è¨˜æ†¶ç‹€æ³":
        st.subheader("ç›®å‰å–®å­—è¨˜æ†¶ç‹€æ³")
        cols = st.columns(5)
        for i in range(1, 6):
            with cols[i-1]:
                st.markdown(f"**â— Level {i}**")
                if level_words[i]:
                    for word in level_words[i]:
                        st.write(word)
                else:
                    st.write("â€”")

    elif tab == "æ°¸ä¹…è¨˜æ†¶å€":
        st.subheader("æ°¸ä¹…è¨˜æ†¶å€å–®å­—")
        if permanent:
            for w in permanent:
                st.write(f"- {w['word']}ï¼š{w['meaning']}")
        else:
            st.info("ç›®å‰æ²’æœ‰å–®å­—é€²å…¥æ°¸ä¹…è¨˜æ†¶å€ã€‚")
            st.write("è«‹ç¹¼çºŒåŠªåŠ›ï¼")

if __name__ == "__main__":
    main()
